#!/usr/bin/env bats

############################ DO NOT EDIT THIS FILE #####################################
# File: student_tests.sh
# 
# DO NOT EDIT THIS FILE
#
# Add/Edit Student tests in student_tests.sh
# 
# All tests in this file must pass - it is used as part of grading!
########################################################################################

# Setup the test shell before each test
setup() {
    test_shell="./dsh"
}

# Test: Pipe with Multiple Commands
@test "pipe with multiple commands" {
  run $test_shell "ls | grep dshlib.c"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Ensure that the output contains the expected file (adjust this according to your environment)
  stripped_output=$(echo "$output" | tr -d '[:space:]')
  expected_output="dshlib.c"
  echo "${stripped_output} -> ${expected_output}"

  [ "$stripped_output" = "$expected_output" ]
  [ "$status" -eq 0 ]
}

# Test: Invalid Command in Pipe
@test "invalid command in pipe" {
  run $test_shell "ls | non_existing_command"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Check that the command fails with the expected error
  [[ "$output" =~ "error: command execution failed" ]]
  [ "$status" -ne 0 ]
}

# Test: Pipe with Empty Output
@test "pipe with empty output" {
  run $test_shell "ls | grep nonexistent_file"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Check that output is empty (and no error occurs)
  [ -z "$output" ]
  [ "$status" -eq 0 ]
}

# Test: Append Redirection
@test "append redirection" {
  run $test_shell "echo 'hello, class' > out.txt"
  run $test_shell "echo 'this is line 2' >> out.txt"
  run $test_shell "cat out.txt"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Ensure content is as expected
  [ "$output" == "hello, class\nthis is line 2" ]
  [ "$status" -eq 0 ]
}

# Test: Input Redirection
@test "input redirection" {
  run $test_shell "echo -e 'line1\nline2' > input.txt"
  run $test_shell "sort < input.txt"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Check sorted output
  [ "$output" == "line1\nline2" ]
  [ "$status" -eq 0 ]
}

# Test: Pipe with Multiple Commands and Mixed Redirection
@test "pipe with multiple commands and mixed redirection" {
  run $test_shell "echo 'line1' > input.txt; cat input.txt | sort | grep line1"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Check that the output contains the correct value
  [ "$output" == "line1" ]
  [ "$status" -eq 0 ]
}

# Test: Pipe with Redirection to Output File
@test "pipe with redirection to output file" {
  run $test_shell "echo 'first line' > output.txt"
  run $test_shell "cat output.txt | grep 'first' > final_output.txt"
  run $test_shell "cat final_output.txt"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Ensure the content matches the expected output
  [ "$output" == "first line" ]
  [ "$status" -eq 0 ]
}

# Test: Command Not Found
@test "command not found" {
  run $test_shell "non_existing_command"

  # Debugging output
  echo "Captured stdout:"
  echo "$output"
  echo "Exit Status: $status"

  # Ensure the error is triggered for a non-existing command
  [[ "$output" =~ "execvp: No such file or directory" ]]
  [ "$status" -ne 0 ]
}

# Example: check ls runs without errors
@test "Example: check ls runs without errors" {
    run $test_shell <<EOF                
ls
EOF

    # Assertions
    [ "$status" -eq 0 ]
}

# Built-in: exit command
@test "Built-in: exit command" {
    run $test_shell <<EOF
exit
EOF
    [ "$status" -eq 0 ]
}

# Built-in: cd without argument (should not change directory)
@test "Built-in: cd without argument (should not change directory)" {
    original_dir=$(pwd)
    run $test_shell <<EOF
cd
pwd
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"$original_dir"* ]]
}

# Built-in: cd with valid directory
@test "Built-in: cd with valid directory" {
    mkdir -p test_dir
    run $test_shell <<EOF
cd test_dir
pwd
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"test_dir"* ]]
    rmdir test_dir
}

# Built-in: cd with invalid directory
@test "Built-in: cd with invalid directory" {
    run $test_shell <<EOF
cd does_not_exist
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"cd failed"* ]]
}

# External: echo command
@test "External: echo command" {
    run $test_shell <<EOF
echo Hello World
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"Hello World"* ]]
}

# Handling empty input
@test "Handling empty input" {
    run $test_shell <<EOF

exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"warning: no commands provided"* ]]
}

# Handling multiple spaces between commands
@test "Handling multiple spaces between commands" {
    run $test_shell <<EOF
ls      -l
exit
EOF
    [ "$status" -eq 0 ]
}

# Handling quoted arguments
@test "Handling quoted arguments" {
    run $test_shell <<EOF
echo "Hello    World"
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"Hello    World"* ]]
}

# Handling failed command execution
@test "Handling failed command execution" {
    run $test_shell <<EOF
invalidcommand
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"Command not found in PATH"* ]]
}

# External: Running a background process
@test "External: Running a background process" {
    run $test_shell <<EOF
sleep 1 &
exit
EOF
    [ "$status" -eq 0 ]
}

# Command substitution
@test "Command substitution" {
    run $test_shell <<EOF
echo \$(echo test)
exit
EOF
    [ "$status" -eq 0 ]
    [[ "$output" == *"test"* ]]
}

# rc: returns last command exit status error
@test "rc: returns last command exit status error" {
    run $test_shell <<EOF
not_a_real_command
rc
exit
EOF
    [[ "$output" == *"2"* ]]  # 2 is "command not found"
}

# rc: returns last command exit status success
@test "rc: returns last command exit status success" {
    run $test_shell <<EOF
ls
rc
exit
EOF
    [[ "$output" == *"0"* ]]  # 0 is "ok"
}

